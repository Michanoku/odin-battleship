/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles.css ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/getUrl.js */ \"./node_modules/css-loader/dist/runtime/getUrl.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);\n// Imports\n\n\n\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ./font/silkscreen.woff */ \"./src/font/silkscreen.woff\"), __webpack_require__.b);\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `@font-face {\n    font-family: 'silkscreen';\n    src: url(${___CSS_LOADER_URL_REPLACEMENT_0___}) format('woff');\n    font-weight: normal;\n    font-style: normal;\n}\n\n:root {\n  font-size: 16px;\n  font-family: 'silkscreen', Arial, Helvetica, sans-serif;\n  --board-margin: 8rem;\n  --space: #131924;\n  --light: #D0EBD1;\n  --ship: #909590;\n  --ship-border: #474A48;\n  --accent: #13E621;\n  --muted: #1B4736;\n  --ship-attacked: #FF1D15;\n}\n\n:root.alt-colors {\n  --accent: #0072B2;\n  --muted: #0A3A53;\n  --ship-attacked: #E69F00;\n}\n\n* {\n  box-sizing: border-box;\n  padding: 0;\n  margin: 0;\n}\n\ninput, button {\n  border: none;\n  outline: none;\n  background: transparent;\n  font: inherit;\n}\n\nhtml {\n  background-color: var(--space);\n  color: var(--accent);\n}\n\nbody {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  grid-template-rows: 2.5rem 3rem 1fr 2.5rem;\n  grid-template-areas: 'nav nav' 'info action' 'player1 player2' 'announce announce';\n  height: 100vh;\n}\n\nnav {\n  grid-area: nav;\n  background-color: var(--light);\n  color: var(--muted);\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding-left: 1rem;\n  padding-right: 1rem;\n  font-size: 1.25rem;\n}\n\n#option-buttons {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  gap: 1rem;\n}\n\n#new-game {\n  color: var(--muted);\n  border: 0.125rem solid var(--muted);\n  padding: 0.25rem;\n  cursor: pointer;\n  font-size: 1.25rem;\n}\n\n#alt-colors {\n  color: var(--muted);\n  border: 0.125rem solid var(--muted);\n  padding: 0.25rem;\n  cursor: pointer;\n  font-size: 1.25rem;\n}\n\n#info, #action {\n  background-color: var(--muted);\n  color: var(--light);\n}\n\n#info {\n  grid-area: info;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 1.625rem;\n}\n\n#action {\n  grid-area: action;\n  display: flex;\n  gap: 0.625rem;\n  justify-content: center;\n  align-items: center;\n}\n\n.game-button {\n  color: var(--light);\n  border: 0.125rem solid var(--light);\n  padding: 0.25rem;\n  cursor: pointer;\n  font-size: 1.25rem;\n}\n\n.game-button:disabled, #fire-button:disabled {\n  color: var(--ship-border);\n  border: 0.125rem solid var(--ship-border);\n  padding: 0.25rem;\n  font-size: 1.25rem;\n}\n\n#fire-button {\n  color: var(--ship-attacked);\n  border: 0.125rem solid var(--ship-attacked);\n  padding: 0.25rem;\n  cursor: pointer;\n  font-size: 1.25rem;\n}\n\n#human-button, #cpu-button, #fire-button, #end-button, #start-button {\n  display: none;\n}\n\n#player1 {\n grid-area: player1; \n border-right: 1px solid var(--accent);\n position: relative;\n}\n\n#player2 {\n  grid-area: player2;\n  border-left: 1px solid var(--accent);\n  position: relative;\n  display: none;\n}\n\n#setup {\n  grid-area: player2;\n  border-left: 1px solid var(--accent);\n  display: grid;\n  grid-template-rows: 2.5rem 1fr 2.5rem;\n  grid-template-areas: 'name' 'ship-selection' 'ship-name';\n}\n\n#announce {\n  border-top: 1px solid var(--accent);\n  grid-area: announce;\n  background-color: var(--space);\n  color: var(--light);\n  display: flex;\n  justify-content: start;\n  align-items: center;\n  padding-left: 1rem;\n  padding-right: 1rem;\n  font-size: 1.25rem;\n}\n\n#name {\n  margin-left: var(--board-margin);\n  margin-right: var(--board-margin);\n  display: flex;\n  justify-content: start;\n  align-items: center;\n  gap: 1rem;\n}\n\n#enter-name {\n  background-color: transparent;\n  border-bottom: 2px solid var(--accent);\n  caret-color: var(--accent);\n  color: var(--accent);\n}\n\n#ship-selection {\n  grid-area: ship-selection;\n  margin-left: var(--board-margin);\n  margin-right: var(--board-margin);\n  display: grid;\n  grid-template-rows: repeat(9, 1fr);\n  grid-template-columns: repeat(10, 1fr);\n  aspect-ratio: 1/1;\n}\n\n#ship-name {\n  grid-area: ship-name;\n  color: var(--accent);\n  display: flex;\n  justify-content: center;\n  align-items: start;\n}\n\n.ship {\n  background-color: var(--ship);\n  box-shadow: inset -2px 0 0 var(--ship-border), inset 0 -2px 0 var(--ship-border), inset 2px 0 0 var(--ship-border), inset 0 2px 0 var(--ship-border);\n  cursor: pointer;\n}\n.ship[data-selected=\"true\"] {\n  background-color: var(--ship-border);\n}\n\n.small {\n  width: 2px;\n  height: 2px;\n  position: absolute;\n  z-index: 0;\n}\n\n.medium { \n  width: 3px;\n  height: 3px;\n  position: absolute;\n  z-index: 0;\n}\n\n.big {\n  width: 4px;\n  height: 4px;\n  position: absolute;\n  z-index: 0;\n}\n\n.star-O { \n  background-color: #9db4ff;\n}\n\n.star-B { \n  background-color: #a2b9ff; \n}\n\n.star-A { \n  background-color: #ffffff; \n}\n\n.star-F { \n  background-color: #fffa86; \n}\n\n.star-G { \n  background-color: #fff220; \n}\n\n.star-K { \n  background-color: #ff8220; \n}\n\n.star-M { \n  background-color: #ff6813; \n}\n\n.gameboard {\n  margin-left: 6rem;\n  margin-right: 6rem;\n  display: grid;\n  grid-template-rows: repeat(11, 1fr);\n  grid-template-columns: repeat(11, 1fr);\n  aspect-ratio: 1/1;\n}\n\n.cell-outer {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 1.125 rem;\n  z-index: 20;\n}\n\n.enemy[data-selected='true'] {\n  color: var(--ship-attacked);\n}\n\n.cell-inner {\n  border: 1px solid var(--accent);\n  z-index: 20;\n}\n\n.cell-clicked {\n  border: 1px solid var(--ship-attacked);\n}\n\n.cell-ship {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background-color: var(--ship);\n  box-shadow: inset -2px 0 0 var(--ship-border), inset 0 -2px 0 var(--ship-border), inset 2px 0 0 var(--ship-border), inset 0 2px 0 var(--ship-border);\n}\n\n.cell-attacked.cell-ship::after {\n  content: \"X\";\n  color: var(--ship-attacked);\n  font-size: 1.625rem;\n}\n\n.cell-attacked:not(.cell-ship) {\n    background: repeating-linear-gradient(\n    -45deg,\n    var(--muted),\n    var(--muted) 2px,\n    transparent 2px,\n    transparent 10px\n  );\n}`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://odin-battleship/./src/styles.css?./node_modules/css-loader/dist/cjs.js\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("{\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://odin-battleship/./node_modules/css-loader/dist/runtime/api.js?\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

eval("{\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!url) {\n    return url;\n  }\n  url = String(url.__esModule ? url.default : url);\n\n  // If url is already wrapped in quotes, remove them\n  if (/^['\"].*['\"]$/.test(url)) {\n    url = url.slice(1, -1);\n  }\n  if (options.hash) {\n    url += options.hash;\n  }\n\n  // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n  if (/[\"'() \\t\\n]|(%20)/.test(url) || options.needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\"), \"\\\"\");\n  }\n  return url;\n};\n\n//# sourceURL=webpack://odin-battleship/./node_modules/css-loader/dist/runtime/getUrl.js?\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("{\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://odin-battleship/./node_modules/css-loader/dist/runtime/noSourceMaps.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("{\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://odin-battleship/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("{\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://odin-battleship/./node_modules/style-loader/dist/runtime/insertBySelector.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://odin-battleship/./node_modules/style-loader/dist/runtime/insertStyleElement.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://odin-battleship/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://odin-battleship/./node_modules/style-loader/dist/runtime/styleDomAPI.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://odin-battleship/./node_modules/style-loader/dist/runtime/styleTagTransform.js?\n}");

/***/ }),

/***/ "./src/cpu.js":
/*!********************!*\
  !*** ./src/cpu.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CPUPlayer: () => (/* binding */ CPUPlayer)\n/* harmony export */ });\n/* harmony import */ var _gameboard_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gameboard.js */ \"./src/gameboard.js\");\n\n\nclass CPUPlayer {\n  constructor() {\n    this.name = 'CPU';\n    this.targetMode = false;\n    this.targetShip = {};\n    this.gameboard = (0,_gameboard_js__WEBPACK_IMPORTED_MODULE_0__.createGameboard)('random');\n    this.targetBoard = new TargetGameboard();\n  }\n\n  // Attacks a cell\n  attackCell() {\n    if (this.targetMode) {\n      // Analyze the target, then pick a new cell to attack\n      this.analyzeTarget();\n      const targetCell = this.targetBoard.getTargetCell();\n      // If there is no good cell, return to hunt mode\n      if (!targetCell) {\n        this.#endTargetMode();\n        return this.attackCell();\n      }\n      return targetCell.coords;\n    } else {\n      // Get a target cell to try\n      const huntCell = this.targetBoard.getHuntCell();\n      return huntCell.coords;\n    }\n  }\n\n  analyzeTarget() {\n    // sort coordinate array (by changing coordinate)\n    const hits = this.targetShip.coords.length;\n    if (hits > 1) {\n      if (!this.targetShip.direction) {\n        const firstRow = this.targetShip.coords[0][0];\n        const secondRow = this.targetShip.coords[1][0];\n        this.targetShip.direction = firstRow === secondRow ? 'horizontal' : 'vertical';\n      }\n      this.targetShip.coords.sort((row, col) => {\n        // Sort by row first\n        if (row[0] !== col[0]) return row[0] - col[0];\n        // If row is the same, sort by col\n        return row[1] - col[1];\n      });\n    };\n    this.#markPotential();\n  }\n\n  #markPotential() {\n    // If we have a direction, proceed along\n    if (this.targetShip.direction) {\n      // If a branchpoint was detected, reset coordinates to follow along the branch\n      if (this.targetShip.branchPoint) {\n        // Find the branching coordinate from the branchpoint\n        const branch = this.#findBranch(this.targetShip.coords, this.targetShip.branchPoint);\n        const branchPoint = this.targetShip.branchPoint;\n        this.targetShip = {\n          coords: [branchPoint, branch],\n          suspectedDirection: '',\n          branch: false,\n          branchPoint: null,\n        };\n        // Analyze target with the new data \n        this.analyzeTarget();\n      }\n      // Add a safety check, in case nothing is found\n      let added = 0;\n      // Find the direction that we are not looking for now\n      const otherDirection = this.targetShip.direction === 'horizontal' ? 'vertical' : 'horizontal';\n      // Check each cell in the target ship\n      this.targetShip.coords.forEach(coord => {\n        // Remove the potential hits for non directional cells\n        this.targetBoard.removePotential(coord, otherDirection);\n        // Add cells that have not been hit but are in direction\n        added += this.targetBoard.addPotential(coord, this.targetShip.direction);\n      });\n      // If ship length invalid and nothing has been added, find adjacent ship\n      if (this.targetShip.coords.length > 5 && !added) {\n        const start = this.targetShip.coords[0];\n        const end = this.targetShip.coords[this.targetShip.coords.length-1];\n        // Check the edges of the current target for potential targets\n        this.targetBoard.checkEdgePotential(start, end, otherDirection);\n        // Mark the targetShip as branched\n        this.targetShip.branch = true;\n      }\n    } else {\n      // If there is no direction, we are dealing with single cell target\n      const coords = this.targetShip.coords[0];\n      this.targetBoard.markSingle(coords)\n    }\n  }\n\n  // Begins target mode after a ship has been found\n  #beginTargetMode(hitCoords) {\n    this.targetMode = true;\n    this.targetShip = {\n      coords: [hitCoords],\n      suspectedDirection: '',\n      branch: false,\n      branchPoint: null,\n    };\n  }\n\n  // Ends target mode after all options are exhausted\n  #endTargetMode() {\n    this.targetMode = false;\n    this.targetShip = {};\n  }\n\n  // Find the branching connection between the coordinates and branchpoint (but not the branchpoint itself)\n  #findBranch(coords, branchPoint) {  \n    const [branchRow, branchCol] = branchPoint;\n    return coords.find(([row, col]) =>\n      (row === branchRow || col === branchCol) &&\n      !(row === branchRow && col === branchCol)\n    );\n  }\n\n  getAttackResults(result, coords) {\n    // Tell gameboard to mark the cell as attacked and possibly hit\n    this.targetBoard.markAttack(coords, result.hit);\n    // If ship was found, and we are not in target mode, go into target mode\n    if (result.hit) {\n      if (!this.targetMode) {\n        this.#beginTargetMode(coords);\n      } else {\n        this.targetShip.coords.push(coords);\n      }\n      if (this.targetShip.branch) {\n        this.targetShip.branchPoint = coords;\n      }\n    }\n    this.targetBoard.updateMap();\n  }\n}\n\nclass TargetGameboard {\n  constructor() {\n    // Create a 10x10 grid to play the game in\n    this.grid = Array.from({ length: 10 }, (_, i) =>\n      Array.from({ length: 10 }, (_, j) => new TargetCell([i, j]))\n    );\n  }\n\n  // Check all cells of the map to see if any are now invalid targets\n  updateMap() {\n    for (const gridRow of this.grid) {\n      for (const cell of gridRow) {\n        this.#checkCell(cell);\n      }\n    }\n  }\n \n  #checkCell(targetCell) {\n    // Get all surrounding cells\n    const surroundingCells = this.#getSurrounding(targetCell.coords);\n    // Mark the cell as impossible if all surrounding cells have been attacked and there was no ship\n    targetCell.possible = !surroundingCells.every(cell => cell.attacked && !cell.ship);\n  }\n\n  // Remove the potential targets along the direction\n  removePotential(coords, direction) {\n    const coordArray = this.#getSurrounding(coords, direction);\n    coordArray.forEach(cell => {\n      cell.potential = false;\n    });\n  }\n\n  // Add the potential targets along the direction\n  addPotential(coords, direction) {\n    let added = 0;\n    const coordArray = this.#getSurrounding(coords, direction);\n    coordArray.forEach(cell => {\n      if (!cell.attacked) {\n        cell.potential = true;\n        added++;\n      }\n    });\n    return added;\n  }\n\n  // Check the potential targets on the edges\n  checkEdgePotential(start, end, direction) {\n    const addFirstPotential = this.#getSurrounding(start, direction);\n    const addSecondPotential = this.#getSurrounding(end, direction);\n    addFirstPotential.concat(addSecondPotential).forEach(cell => {\n      if (!cell.attacked) {\n        cell.potential = true;\n      };\n    });\n  }\n\n  // Check potential for a single cell\n  markSingle(coords) {\n    const surroundingCells = this.#getSurrounding(coords);\n    surroundingCells.forEach(cell => {\n      if (!cell.attacked) {\n        cell.potential = true;\n      }\n    });\n  }\n\n  // Get possible cells surrounding this cell\n  #getSurrounding(baseCoords, direction = null) {\n    const [baseRow, baseCol] = baseCoords;\n    const calculations = new Array();\n    // Add needed calculations for horizontal, vertical or both\n    if (direction === 'horizontal' || direction === null) {\n      calculations.push([0, -1]);\n      calculations.push([0, 1]);\n    } \n    if (direction === 'vertical' || direction === null) {\n      calculations.push([-1, 0]);\n      calculations.push([1, 0]);\n    }\n    // Calculate the array of coordinates to check, add only if they are valid\n    const checkArray = new Array();\n    calculations.forEach(coord => {\n      const [row, col] = coord;\n      const newRow = baseRow + row;\n      const newCol = baseCol + col;\n      if (newRow >= 0 && newRow <= 9 && newCol >= 0 && newCol <= 9) {\n        checkArray.push(this.grid[newRow][newCol]);\n      }\n    });\n    return checkArray;\n  }\n\n  // Mark a cell as attacked. If there is a hit, mark it, potential is now false\n  markAttack(coords, hit) {\n    const [row, col] = coords;\n    const cell = this.grid[row][col];\n    cell.attacked = true;\n    cell.ship = hit;\n    cell.potential = false;\n  }\n\n  getHuntCell() {\n    // Get all cells in a pattern if they are not hit or marked impossible\n    const huntCells = new Array();\n    for (const gridRow of this.grid) {\n      for (const cell of gridRow) {\n        const [row, col] = cell.coords;\n        if ((row + col) % 2 === 0 && !cell.noHunt()) {\n          huntCells.push(cell);\n        }\n      }\n    }\n    if (!huntCells.length) {\n      // find other cells not yet tried\n      for (const gridRow of this.grid) {\n        for (const cell of gridRow) {\n          if (!cell.attacked) {\n           huntCells.push(cell);\n          }\n        }\n      }\n    }\n    // Pick a random cell from the array\n    const randomCell = Math.floor(Math.random() * huntCells.length);\n    return huntCells[randomCell];\n  }\n\n  // Get a cell marked as potential target\n  getTargetCell() {\n    const targetCells = new Array();\n    for (const gridRow of this.grid) {\n      for (const cell of gridRow) {\n        if (cell.potential) {\n          targetCells.push(cell);\n        }\n      }\n    }\n    // If no potential targets remain return null\n    if (!targetCells.length) {\n      return null;\n    }\n    // Pick a random cell from the array\n    const randomCell = Math.floor(Math.random() * targetCells.length);\n    return targetCells[randomCell];\n  }\n}\n\n// The class for the AI target cell\nclass TargetCell{\n  constructor(coords) {\n    this.coords = coords;\n    this.attacked = false;\n    this.ship = false;\n    this.potential = false;\n    this.possible = true;\n  }\n\n  noHunt() {\n    return this.attacked || !this.possible;\n  }\n}\n\n\n\n//# sourceURL=webpack://odin-battleship/./src/cpu.js?\n}");

/***/ }),

/***/ "./src/font/silkscreen.woff":
/*!**********************************!*\
  !*** ./src/font/silkscreen.woff ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{module.exports = __webpack_require__.p + \"d462a9b78b0f80dabc6c.woff\";\n\n//# sourceURL=webpack://odin-battleship/./src/font/silkscreen.woff?\n}");

/***/ }),

/***/ "./src/gameboard.js":
/*!**************************!*\
  !*** ./src/gameboard.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGameboard: () => (/* binding */ createGameboard),\n/* harmony export */   randomPlacement: () => (/* binding */ randomPlacement)\n/* harmony export */ });\n/* harmony import */ var _ships_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ships.js */ \"./src/ships.js\");\n\n\nclass Gameboard {\n  constructor(ships = null) {\n    // Create a 10x10 grid to play the game in\n    this.grid = Array.from({ length: 10 }, (_, i) =>\n      Array.from({ length: 10 }, (_, j) => new Cell([i, j]))\n    );\n    // The gameboard initially has 0 ships / sunk ships\n    this.ships = 0;\n    this.sunkShips = 0;\n\n    // If we passed ships to the board, place them immediately\n    if (ships) {\n      // If we just passed random, place random ships\n      if (ships === 'random') {\n        this.#randomizeBoard();\n      } else {\n        // Place each ship in it's location\n        for (const ship in ships) {\n          const {coord, size, direction} = ships[ship]; \n          this.placeShip(coord, size, direction);\n        }\n      }\n    }\n  }\n\n  // Place a ship on the board at given coordinates and direction\n  placeShip(coord, size, direction) {\n    // Get the starting coordinates\n    const [row, col] = coord;\n    // Check if that cell has this much space adjacent\n    const space = this.grid[row][col].hasSpace(size);\n    // If there is no space or not in the desired location\n    if (!space || !space.includes(direction)) {\n        return null;\n    }\n    // Create the ship based on the size\n    const newShip = new _ships_js__WEBPACK_IMPORTED_MODULE_0__.Ship(size);\n\n    // Set all coordinates that the ship covers to contain the ship\n    const allCoords = this.#getAllCoords(coord, size, direction);\n    for (const coord of allCoords) {\n      const [row, col] = coord;\n      this.grid[row][col].ship = newShip;\n    }\n    this.ships++;\n    // If a ship was placed, check and update cells neighbors\n    for (let i = 0; i < 10; i++) {\n      for (let j = 0; j < 10; j++) {\n        this.#updateCellNeighbors(this.grid[i][j]);\n      }\n    }\n    return newShip;\n  }\n\n  // Get all coordinates that would allow a ship of the size to be placed\n  #getAllCoords(coord, size, direction) {\n    // Create an array to house all coordinates\n    const allCoords = new Array();\n    // Get the start of the ships coordinates and the end\n    const [row, col] = coord;\n    // Add the first coordinate\n    if (direction === 'horizontal') {\n      for (let i = 0; i < size; i++) {\n        allCoords.push([row, col + i]);\n      }\n    } else {\n      for (let i = 0; i < size; i++) {\n        allCoords.push([row + i, col]);\n      }\n    }\n    return allCoords;\n  }\n\n  // Update neighbors in case a ship was placed in them\n  #updateCellNeighbors(cell) {\n    // Create two variables to hold the number of free spaces in each direction\n    let horizontalSpace = 0;\n    let verticalSpace = 0;\n    // Get coordinates and calculate new coordinates to check\n    const [row, col] = cell.coords;\n    for (let i = 1; i < 5; i++) {\n      const newCol = col + i;\n      if (newCol > 9 || this.grid[row][newCol].ship) {\n        break;\n      }\n      horizontalSpace++;\n    };\n    for (let i = 1; i < 5; i++) {\n      const newRow = row + i;\n      if (newRow > 9 || this.grid[newRow][col].ship) {\n        break;\n      }\n      verticalSpace++;\n    };\n    // Save the new space\n    cell.vertical = verticalSpace;\n    cell.horizontal = horizontalSpace;\n  }\n\n  // Randomize a board of ships\n  #randomizeBoard() {\n    // Place all ships randomly on the map\n    const ships = [5, 4, 3, 3, 2]\n    for (const ship of ships) {\n      this.#placeShipRandomly(ship);\n    }\n  }\n\n  // Place a ship of a given size on the board at random\n  #placeShipRandomly(size) {\n    // Select a random coordinate on the board\n    const cell = this.#selectRandomCoord(size);\n    // Select the direction the ship will have from the coordinate\n    const direction = this.#getDirection(cell, size);\n    // Get the actual coordinate number array\n    const coord = cell.coords;\n    // Place the ship at the location in the direction and return it\n    const ship = this.placeShip(coord, size, direction);\n    return ship;\n  }\n\n  // Select a random coordinate for the ship to be placed\n  #selectRandomCoord(size) {\n    // Get an array of possible coordinates\n    const freeCoords = this.#getFreeCoords(size);\n    // Get the amount of coordinates returned and get one of them at random\n    const totalCoords = freeCoords.length;\n    const randomPosition = Math.floor(Math.random() * totalCoords);\n    return freeCoords[randomPosition];\n  }\n\n  // Get all possible starting locations for a ship of the size\n  #getFreeCoords(shipSize) {\n    // Create array for coordinates and calculate required space next to cell\n    const freeCoords = new Array();\n    const required = shipSize - 1;\n    // Loop over the board and save all cells that have enough adjacent space\n    for (const row of this.grid) {\n      for (const cell of row) {\n        if (cell.horizontal >= required || cell.vertical >= required) {\n          freeCoords.push(cell);\n        }\n      }\n    }\n    return freeCoords;\n  }\n\n  // Get a direction for the ship to be placed (horizontal or vertical)\n  #getDirection(cell, size) {\n    // Check the possible directions for a ship of the size on that cell\n    const possibleDirections = cell.hasSpace(size);\n    // If the length is 1, there is only 1 possible location, return it\n    if (possibleDirections.length === 1) {\n      return possibleDirections[0];\n    } else {\n      // Else return one possible location at random\n      const random = Math.floor(Math.random() * 2);\n      return possibleDirections[random];\n    }\n  }\n\n  // Place all ships randomly on the map\n  simulateRandomPlacement() {\n    const shipPlacement = {\n      'Leviathan': {coord: [], size: 5, direction: ''},\n      'Interceptor': {coord: [], size: 4, direction: ''},\n      'Cruiser': {coord: [], size: 3, direction: ''},\n      'Destroyer': {coord: [], size: 3, direction: ''},\n      'Patrol': {coord: [], size: 2, direction: ''},\n    }\n    // Place each ship one by one\n    for (const ship in shipPlacement) {\n      const size = shipPlacement[ship].size;\n      const [coord, direction] = this.#simulateRandomShip(size);\n      shipPlacement[ship].coord = coord;\n      shipPlacement[ship].direction = direction;\n    };\n    return shipPlacement;\n  }\n\n  // Simulate one ship being placed randomly\n  #simulateRandomShip(size) {\n    // Select a random coordinate on the board\n    const cell = this.#selectRandomCoord(size);\n    // Select the direction the ship will have from the coordinate\n    const direction = this.#getDirection(cell, size);\n    // Get the actual coordinate number array\n    const coord = cell.coords;\n    // Place the ship at the location in the direction and return it\n    this.placeShip(coord, size, direction);\n    return [coord, direction];\n  }\n\n  // Receive the attack and return the result\n  receiveAttack(coord) {\n    // Get the targetcell of the attack and set attacked to true\n    const [row, col] = coord;\n    const targetCell = this.grid[row][col];\n    targetCell.attacked = true;\n    // If there is a ship on the cell, hit it and see if its sunk\n    if (targetCell.ship) {\n      targetCell.ship.hit();\n      if(targetCell.ship.isSunk()) {\n        // If it is sunk, add it to sunk ships\n        this.sunkShips++;\n        // If all ships are sunk, return so\n        if (this.sunkShips === this.ships) {\n          return {hit: true, allSunk: true};\n        }\n      }\n      // Return the attack was a hit but not all ships are sunk\n      return {hit: true, allSunk: false};\n    }\n    // Returm the attack was not a hit and not all ships are sunk\n    return {hit: false, allSunk: false};\n  }\n}\n\n// The class for a cell on the board\nclass Cell {\n  constructor(coords) {\n    this.coords = coords;\n    this.attacked = false;\n    this.ship = null;\n    this.horizontal = this.initialize(\"horizontal\", coords);\n    this.vertical = this.initialize(\"vertical\", coords);\n  }\n\n  // Initialize the cell\n  initialize(direction, coords) {\n    // Get the coordinates for the cell, and set free space to 0\n    let freeSpace = 0;\n    const [row, col] = coords;\n    // Save a different coordinate based on the direction to check\n    const moving = direction === 'horizontal' ? col : row; \n    // The biggest ship is 5, so only need to check for 5 free spaces\n    for (let i = 1; i < 5; i++) {\n      const newCoord = moving + i;\n      // If we go over the edge, stop early (no more free spaces)\n      if (newCoord > 9) {\n        break;\n      }\n      freeSpace++;\n    }\n    return freeSpace;\n  }\n\n  // Check if a ship of the size has space from this cell\n  hasSpace(shipSize) {\n    // The required space includes the cell, so we can subtract 1\n    const required = shipSize - 1;\n    // Check if horizontal or vertical space is available\n    const horizontal = this.horizontal >= required;\n    const vertical = this.vertical >= required;\n    const available = [];\n    // Push available directions\n    if (horizontal) {\n      available.push('horizontal');\n    } \n    if (vertical) {\n      available.push('vertical');\n    }\n    return available;\n  }\n}\n\n// Create and return a new Gameboard\nfunction createGameboard(ships = null) {\n  return new Gameboard(ships);\n}\n\n// Create a mock gameboard and return the random placement\nfunction randomPlacement() {\n  const mockBoard = new Gameboard();\n  const shipPlacement = mockBoard.simulateRandomPlacement(); \n  return shipPlacement\n}\n\n\n\n//# sourceURL=webpack://odin-battleship/./src/gameboard.js?\n}");

/***/ }),

/***/ "./src/gameflow.js":
/*!*************************!*\
  !*** ./src/gameflow.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles.css */ \"./src/styles.css\");\n/* harmony import */ var _players_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./players.js */ \"./src/players.js\");\n/* harmony import */ var _cpu_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cpu.js */ \"./src/cpu.js\");\n/* harmony import */ var _gameboard_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gameboard.js */ \"./src/gameboard.js\");\n/* harmony import */ var _interface_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interface.js */ \"./src/interface.js\");\n\n\n\n\n\n\n\n\n// The state that keeps the players and the current turn\nconst state = {\n  players: new Array(),\n  turn: 0,\n  initializedTurns: false,\n};\n\n// Create a player and push it to the players array\nfunction addPlayer(data) {\n  if (data.cpu) {\n    state.players.push(new _cpu_js__WEBPACK_IMPORTED_MODULE_2__.CPUPlayer());\n  } else {\n    const name = data.name;\n    const ships = data.ships;\n    state.players.push(new _players_js__WEBPACK_IMPORTED_MODULE_1__.Player(name, ships));\n  }\n}\n\n// Start the game\nfunction start() {\n  // Wait for players to finish their setup\n  waitForPlayers();\n  // Wait for players to reset the board\n  waitForReset();\n  // Wait for players to request random ship placement\n  waitForRandomPlacement();\n  // Initialize the game\n  (0,_interface_js__WEBPACK_IMPORTED_MODULE_4__.initializeGame)();\n}\n\n// This starts the game phase of taking turns between players\nfunction takeTurns() {\n  if (!state.initializedTurns) {\n    // Wait for a player to start their turn\n    waitforStart();\n    // Wait for a player to attack\n    waitForAttack();\n    // Wait for a player to end their turn\n    waitForEnd();\n    state.initializedTurns = true;\n  }\n  // Direct the interface to initialize the first turn\n  (0,_interface_js__WEBPACK_IMPORTED_MODULE_4__.turn)(state, 'first');\n}\n\n// Wait for players to finish their setup\nfunction waitForPlayers() {\n  document.addEventListener('playersReady', (event) => {\n    const players = event.detail;\n    players.forEach(player => {\n      addPlayer(player);\n    });\n    takeTurns();\n  });\n}\n\n// Wait for a player to start a new game\nfunction waitForReset() {\n  document.addEventListener('initialize', () => {\n    // Reset all states\n    state.players = new Array();\n    state.turn = 0;\n    // Initialize the game from the start\n    (0,_interface_js__WEBPACK_IMPORTED_MODULE_4__.initializeGame)('new');\n  });\n}\n\n// If the player wants to randomize the placement board\nfunction waitForRandomPlacement() {\n  document.addEventListener('randomPlacement', () => {\n    // Get random ship placements from the gameboard\n    const shipPlacement = (0,_gameboard_js__WEBPACK_IMPORTED_MODULE_3__.randomPlacement)();\n    // Instruct interface to place them\n    (0,_interface_js__WEBPACK_IMPORTED_MODULE_4__.randomizeShips)(shipPlacement);\n  });\n}\n\n// Wait for the player to start the round\nfunction waitforStart() {\n  document.addEventListener('requestStart', () => {\n    // Instruct interface to start the turn with the current state\n    (0,_interface_js__WEBPACK_IMPORTED_MODULE_4__.turn)(state, 'start');\n  });\n}\n\n// Wait for the player to launch their attack\nfunction waitForAttack() {\n  document.addEventListener('fire', (event) => {\n    // Get the coordinates and the receiving player\n    const coords = event.detail;\n    const receivingPlayer = state.turn === 0 ? state.players[1] : state.players[0];\n    // Let the receiving players gameboard receive the attack and get the result\n    const result = receivingPlayer.gameboard.receiveAttack(coords);\n    // Instruct the interface to show the attack result \n    (0,_interface_js__WEBPACK_IMPORTED_MODULE_4__.registerAttack)(state, result, coords, false);\n  });\n}\n\n// Wait for the player to end the round\nfunction waitForEnd() {\n  document.addEventListener('requestEnd', () => {\n    // Set turn to the next turn \n    state.turn = state.turn === 0 ? 1 : 0;\n    // If the player is a cpu, take it's turn\n    if (state.players[state.turn].constructor === _cpu_js__WEBPACK_IMPORTED_MODULE_2__.CPUPlayer) {\n      const cpu = state.players[state.turn];\n      const humanPlayer = state.turn === 0 ? state.players[1] : state.players[0];\n      // Let the cpu decide on an attack coordinate\n      const attackCoords = cpu.attackCell();\n      // Let the human players gameboard receive the attack and get the result\n      const result = humanPlayer.gameboard.receiveAttack(attackCoords);\n      // Let the cpu know about the attack result\n      cpu.getAttackResults(result, attackCoords);\n      (0,_interface_js__WEBPACK_IMPORTED_MODULE_4__.registerAttack)(state, result, attackCoords, true);\n      state.turn = state.turn === 0 ? 1 : 0;\n    } else {\n      // Instruct the interface to end the turn\n      (0,_interface_js__WEBPACK_IMPORTED_MODULE_4__.turn)(state, 'end');\n    }\n  });\n}\n\n// Start the game\nstart();\n\n//# sourceURL=webpack://odin-battleship/./src/gameflow.js?\n}");

/***/ }),

/***/ "./src/interface.js":
/*!**************************!*\
  !*** ./src/interface.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeGame: () => (/* binding */ initializeGame),\n/* harmony export */   randomizeShips: () => (/* binding */ randomizeShips),\n/* harmony export */   registerAttack: () => (/* binding */ registerAttack),\n/* harmony export */   turn: () => (/* binding */ turn)\n/* harmony export */ });\n// Required Nodes\nconst enterName = document.querySelector('#enter-name');\nconst confirmButton = document.querySelector('#confirm-button');\nconst randomButton = document.querySelector('#random-button');\nconst cpuButton = document.querySelector('#cpu-button');\nconst humanButton = document.querySelector('#human-button');\nconst resetButton = document.querySelector('#reset-button');\nconst fireButton = document.querySelector('#fire-button');\nconst newGameButton = document.querySelector('#new-game');\nconst altColorsButton = document.querySelector('#alt-colors');\nconst startButton = document.querySelector('#start-button');\nconst endButton = document.querySelector('#end-button');\nconst player1 = document.querySelector(`#player1`);\nconst player2 = document.querySelector(`#player2`); \nconst setup = document.querySelector('#setup');\nconst shipSelection = document.querySelector('#ship-selection');\nconst announce = document.querySelector('#announce');\nconst shipName = document.querySelector('#ship-name');\nconst currentPlayer = document.querySelector('#current-player');\n\n// The data for the ship currently dragged\nconst dragData = {\n  ship: '',\n  direction: '',\n  size: 0,\n}\n\nconst setupData = {\n  players: new Array(),\n  shipPlacement: {\n    'Patrol': {},\n    'Cruiser': {},\n    'Destroyer': {},\n    'Interceptor': {},\n    'Leviathan': {},\n  },\n}\n\n// Keep track of some states like current selected target cell and turn\nconst state = {\n  attackTarget: [],\n  turnEnd: false,\n  initialized: false,\n}\n\n/* ----- GAME SETUP ----- */\n// Initialize the game by creating the background, the setups and listeners\nfunction initializeGame() {\n  if (!state.initialized) {\n    createStars(1);\n    createStars(2);\n    addListeners();\n    state.initialized = true;\n  }\n  createSetupBoard();\n  createShipSelection();\n}\n\n// Create a random starry background\nfunction createStars(player) {\n  const playerField = document.querySelector(`#player${player}`);\n  const numStars = Math.floor(Math.random() * 11) + 60; // About 60 stars\n\n  // Pick random weights of stars\n  function weightedRandom(weights) {\n    const total = Object.values(weights).reduce((a, b) => a + b, 0);\n    const rand = Math.random() * total;\n    let sum = 0;\n    for (const [key, weight] of Object.entries(weights)) {\n      sum += weight;\n      if (rand < sum) return key;\n    }\n  }\n  \n  // Set the weights for sizes and colors of stars\n  const sizeWeights = { small: 70, medium: 25, large: 5 };\n  const colorWeights = {\n      'star-O' : 5,\n      'star-B' : 10,\n      'star-A' : 15,\n      'star-F' : 15,\n      'star-G' : 15,\n      'star-K' : 20,\n      'star-M' : 20,\n  };\n\n  // For every star, set a random color and size and position\n  for (let i = 0; i < numStars; i++) {\n    const star = document.createElement('div');\n\n    const sizeClass = weightedRandom(sizeWeights);\n    const colorClass = weightedRandom(colorWeights);\n\n    star.classList.add(sizeClass, colorClass);\n\n    // Set the position but do not get too close to the border\n    const margin = 5;\n    const top = margin + Math.random() * (100 - margin * 2);\n    const left = margin + Math.random() * (100 - margin * 2);\n\n    star.style.top = `${top}%`;\n    star.style.left = `${left}%`;\n\n    playerField.appendChild(star);\n  }\n}\n\n// Add all listeners needed\nfunction addListeners() {\n  newGameButton.addEventListener('click', newGame);\n  altColorsButton.addEventListener('click', altColors);\n  resetButton.addEventListener('click', resetBoard);\n  randomButton.addEventListener('click', callRandomizer);\n  enterName.addEventListener('input', validateUserSetup);\n  humanButton.addEventListener('click', humanPlayer2);\n  confirmButton.addEventListener('click', () => {\n    // Confirm a human player\n    confirmPlayer(false);\n  });\n   cpuButton.addEventListener('click', () => {\n    // Confirm a cpu player\n    confirmPlayer(true);\n  });\n  fireButton.addEventListener('click', () => {\n    // Carry out attack and get results back\n    document.dispatchEvent(new CustomEvent('fire', {detail: state.attackTarget}));\n  });\n  startButton.addEventListener('click', () => {\n    // Show your current map and attack map \n    document.dispatchEvent(new CustomEvent('requestStart'));\n  });\n  endButton.addEventListener('click', () => {\n    // Hide maps and end the turn\n    document.dispatchEvent(new CustomEvent('requestEnd'));\n  });\n}\n\n// Creates the board the player places ships on \nfunction createSetupBoard() {\n  const gameboardDiv = document.createElement('div');\n  const coordMap = {\n    1: 'A',\n    2: 'B',\n    3: 'C',\n    4: 'D',\n    5: 'E',\n    6: 'F',\n    7: 'G',\n    8: 'H',\n    9: 'I',\n    10: 'J',\n  }\n  gameboardDiv.classList.add('gameboard');\n  // Create a grid of cells to place ships on\n  for (let i = 0; i < 11; i++) {\n    for (let j = 0; j < 11; j++) {\n      const cell = document.createElement('div');\n      // Outer cells have coordinates on them\n      if (i === 0) {\n        cell.classList.add('cell-outer');\n        if (j !== 0) {\n          cell.textContent = j;\n        }\n      } else if (j === 0) {\n        cell.classList.add('cell-outer');\n        cell.textContent = coordMap[i];\n      } else {\n        // Inner cells can accept ships\n        cell.classList.add('cell-inner');\n        cell.dataset.vertical = i - 1;\n        cell.dataset.horizontal = j - 1;\n        // Required to allow dropping\n        cell.addEventListener(\"dragover\", (event) => {\n          event.preventDefault(); \n        });\n        // Event Listener to drop a ship \n        cell.addEventListener(\"drop\", () => {\n          dropShip(cell);\n        });\n      }\n      gameboardDiv.appendChild(cell);\n    }\n  }\n  player1.appendChild(gameboardDiv);\n}\n\n// Creates the ships that can be dragged and dropped by the user\nfunction createShipSelection() {\n  // Define coordinate groups for each class of direction and ship type\n  const directionMap = {\n    core: [\n      [0, 0], [0, 3], [0, 7],\n      [4, 0], [4, 5],\n    ],\n    horizontal: [\n      [0, 1], [0, 4], [0, 5], [0, 8], [0, 9],\n      [4, 1], [4, 2], [4, 3], [4, 6], [4, 7], [4, 8], [4, 9],\n    ],\n    vertical: [\n      [1, 0], [1, 3], [2, 3], [1, 7], [2, 7],\n      [5, 0], [6, 0], [7, 0],\n      [5, 5], [6, 5], [7, 5], [8, 5],\n    ],\n  };\n  const shipMap = {\n    'Patrol': [\n      [0,0], [0,1], [1,0]\n    ],\n    'Cruiser': [\n      [0,3], [0,4], [0,5], [1,3], [2,3]\n    ],\n    'Destroyer': [\n      [0,7], [0,8], [0,9], [1,7], [2,7]\n    ],\n    'Interceptor': [\n      [4,0], [4,1], [4,2], [4,3], [5,0], [6,0], [7,0]\n    ],\n    'Leviathan': [\n      [4,5], [4,6], [4,7], [4,8], [4,9], [5,5], [6,5], [7,5], [8,5]\n    ]\n  };\n  // Create maps for for the coordinates to lookup faster\n  const coordDirectionMap = new Map();\n  for (const [className, coords] of Object.entries(directionMap)) {\n    for (const [row, col] of coords) {\n      coordDirectionMap.set(`${row},${col}`, className);\n    }\n  }\n  const coordShipMap = new Map();\n  for (const [className, coords] of Object.entries(shipMap)) {\n    for (const [row, col] of coords) {\n      coordShipMap.set(`${row},${col}`, className);\n    }\n  }\n  // Create the grid for ship selection and place the ships inside\n  for (let i = 0; i < 9; i++) {\n    for (let j = 0; j < 10; j++) {\n      // Create a cell and give it the standart class\n      const cell = document.createElement('div');\n      cell.classList.add('cell-inner');\n      // Get the class and if there is one, set it\n      const shipClass = coordShipMap.get(`${i},${j}`);\n      if (shipClass) {\n        cell.dataset.ship = shipClass;\n      }\n      // Get the direction and set some values depending on the direction\n      const directionClass = coordDirectionMap.get(`${i},${j}`);\n      if (directionClass) {\n        // Core cells have both vertical and horizontal, so set both to true\n        cell.dataset.vertical = 'true';\n        cell.dataset.horizontal = 'true';\n        // If the cell is vertical or horizontal instead, set the opposite false\n        if (directionClass === 'vertical') {\n          cell.dataset.horizontal = 'false';\n        } else if (directionClass === 'horizontal') {\n          cell.dataset.vertical = 'false';\n        }\n        cell.dataset.current = 'vertical';\n        // All ships are vertical at first, so only set ship for those cells\n        if (directionClass !== 'horizontal') {\n          cell.classList.add('ship');\n        }\n        // Enable dragging.\n        cell.draggable = true;\n        // Add Event Listeners for grad, click and doubleclick\n        cell.addEventListener(\"dragstart\", (event) => {\n          dragShip(event, cell);\n        });\n        cell.addEventListener('click', () => {\n          selectShip(cell);\n        });\n        cell.addEventListener('dblclick', () => {\n          rotateShip(cell);\n        });\n      }\n      shipSelection.appendChild(cell);\n    }\n  }\n  // Set some other node to be visible and reset some values to initial values\n  resetButton.style.display = 'block';\n  confirmButton.style.display = 'block';\n  randomButton.style.display = 'block';\n  confirmButton.disabled = true;\n  announce.textContent = 'Click to select a ship. Double click to rotate. Drag to place.';\n  enterName.value = '';\n  enterName.focus();\n}\n\n// When the player selects to start a new game, initialize everything\nfunction newGame() {\n  const choice = confirm(\"Start a new game? Current progress will be lost.\");\n  if (choice) {\n    // All DOM objects need to be rest to initial state\n    currentPlayer.textContent = 'Player 1';\n    confirmButton.disabled = true;\n    shipName.textContent = '';\n    setupData.players = new Array();\n    setupData.shipPlacement = {\n      'Patrol': {},\n      'Cruiser': {},\n      'Destroyer': {},\n      'Interceptor': {},\n      'Leviathan': {},\n    },\n\n    // Reset all objects \n    document.querySelectorAll('div.gameboard').forEach(div => div.remove());\n    while (shipSelection.firstChild) {\n      shipSelection.removeChild(shipSelection.firstChild);\n    }\n    resetMaps();\n    // Hide objects to hide\n    player2.style.display = 'none';\n    cpuButton.style.display = 'none';\n    // Show objects to show\n    setup.style.display = 'grid';\n    resetButton.style.display = 'block';\n    confirmButton.style.display = 'block';\n    randomButton.style.display = 'block';\n    cpuButton.style.display = 'none';\n    humanButton.style.display = 'none';\n    fireButton.style.display = 'none';\n    startButton.style.display = 'none';\n    endButton.style.display = 'none';\n    // Dispatch event to reset\n    document.dispatchEvent(new CustomEvent('initialize'));\n  }\n}\n\nfunction resetMaps() {\n  [player1, player2].forEach(player =>\n    player.querySelectorAll('.gameboard').forEach(el => el.remove())\n  );\n}\n\n// Allows switching between color modes for accessibility\nfunction altColors() {\n  document.documentElement.classList.toggle('alt-colors');\n}\n\n// Reset the placement board\nfunction resetBoard() {\n  // Reset placed ship data\n  setupData.shipPlacement = {\n    'Patrol': {},\n    'Cruiser': {},\n    'Destroyer': {},\n    'Interceptor': {},\n    'Leviathan': {},\n  }\n  // Reset ship placement\n  const placedShips = document.querySelectorAll('.cell-ship');\n  placedShips.forEach(ship => {\n    ship.classList.remove('cell-ship');\n  });\n  // Reset ship selection\n  const shipSelection = document.querySelectorAll('[data-current]');\n  shipSelection.forEach(cell => {\n    cell.dataset.current = 'vertical';\n    cell.dataset.selected = 'false';\n    if (cell.dataset.vertical === 'true') {\n      cell.classList.add('ship');\n    } else {\n      cell.classList.remove('ship');\n    }\n  });\n  // State and erase the players placed ship data and name\n  enterName.value = '';\n  enterName.focus();\n  confirmButton.disabled = true;\n  shipName.textContent = '';\n}\n\n// Call the randomizer (it will send a randomized board)\nfunction callRandomizer() {\n  document.dispatchEvent(new CustomEvent('randomPlacement'));\n}\n\n// Confirm a player entry\nfunction confirmPlayer(cpu) {\n\n  // create the player with the name and placed ships.\n  resetButton.style.display = 'none';\n  confirmButton.style.display = 'none';\n  randomButton.style.display = 'none';\n  cpuButton.style.display = 'none';\n  humanButton.style.display = 'none';\n  if (cpu) {\n    setupData.players.push({cpu: true});\n  } else {\n    setupData.players.push({name: enterName.value, ships: Object.assign({}, setupData.shipPlacement)});\n  }\n  if (setupData.players.length === 2) {\n    document.dispatchEvent(new CustomEvent('playersReady', {detail: setupData.players})); \n  } else {\n    resetBoard();\n    currentPlayer.textContent = 'Player 2';\n    announce.textContent = 'Do you want to play against a human or the CPU?';\n    setup.style.display = 'none';\n    player1.style.display = 'none';\n    confirmButton.style.display = 'none';\n    resetButton.style.display = 'none';\n    randomButton.style.display = 'none';\n    cpuButton.style.display = 'block';\n    humanButton.style.display = 'block';\n    startButton.style.display = 'none';\n    endButton.style.display = 'none';\n  }\n}\n\n// Check if the user is finished setting up\nfunction validateUserSetup() {\n  const nameValid = enterName.value.trim().length > 0;\n  const shipsValid = Object.values(setupData.shipPlacement)\n    .every(ship => ship && Object.keys(ship).length > 0);\n\n  confirmButton.disabled = !(nameValid && shipsValid);\n}\n\n// If player 2 is human, show appropriate content\nfunction humanPlayer2() {\n  setup.style.display = 'grid';\n  player1.style.display = 'block';\n  confirmButton.style.display = 'block';\n  resetButton.style.display = 'block';\n  randomButton.style.display = 'block';\n  cpuButton.style.display = 'none';\n  humanButton.style.display = 'none';\n  announce.textContent = 'Click to select a ship. Double click to rotate. Drag to place.';\n}\n\n// What happens when a ship is selected\nfunction selectShip(clicked) {\n  // Save some nodes first\n  const allShips = document.querySelectorAll('.ship');\n  // Make sure only the same ships are selected\n  const sameShips = document.querySelectorAll(`div[data-ship='${clicked.dataset.ship}']`);\n  allShips.forEach(ship => {\n    ship.dataset.selected = false;\n  });\n  sameShips.forEach(ship => {\n    ship.dataset.selected = true;\n  });\n  // Show the name of the selected ship\n  shipName.textContent = clicked.dataset.ship;\n}\n\n// Rotate the ship in the grid\nfunction rotateShip(clicked) {\n  // Get the current direction and other direction \n  const current = clicked.dataset.current;\n  const other = current === 'vertical' ? 'horizontal' : 'vertical';\n  // Remove ship from the current, add it to the other, and set the current to other\n  const allShips = document.querySelectorAll(`div[data-ship='${clicked.dataset.ship}']`);\n  allShips.forEach(ship => {\n    if (ship.dataset[other] === 'true') {\n      ship.classList.add('ship');\n    } else {\n      ship.classList.remove('ship');\n    }\n    ship.dataset.current = other;\n  });\n}\n\n// Custom drag event\n// https://stackoverflow.com/questions/29131466/change-ghost-image-in-html5-drag-and-drop\nfunction dragShip(event, cell) {\n  // The sizes of the ships\n  const shipMap = {\n    'Patrol': 2,\n    'Cruiser': 3,\n    'Destroyer': 3,\n    'Interceptor': 4,\n    'Leviathan': 5,\n  }\n  const direction = cell.dataset.current;\n  const size = shipMap[cell.dataset.ship];\n  dragData.direction = direction;\n  dragData.size = size;\n  dragData.ship = cell.dataset.ship;\n  // Create a ghost to use instead of the default\n  const dragGhost = createGhost(cell, size, direction)\n  // Get the size and replace the default with the ghost\n  const cellSize = cell.getBoundingClientRect();\n  // Also set the cursor to the center of the ghost\n  event.dataTransfer.setDragImage(dragGhost, cellSize.width / 2, cellSize.height / 2);\n  // Once the drag is over, remove the ghost again\n  event.target.addEventListener(\n    \"dragend\",\n    function () {\n      dragGhost.remove();\n    },\n    { once: true }\n  );\n};\n\n// Create a ghost image for the draggable content to replace the default\nfunction createGhost(cell, size, direction) {\n  // Create a ghost grid to imitate the grid the cell is currently on\n  const ghost = document.createElement(\"div\");\n  ghost.style.display = \"grid\";\n  ghost.style.position = \"absolute\";\n  ghost.style.top = \"-9999px\";\n  ghost.style.left = \"-9999px\";\n\n  // Set the direction based on the ship data\n  ghost.style.gridAutoFlow = direction === \"horizontal\" ? \"column\" : \"row\";\n\n  // Get the size of the cell \n  const cellSize = cell.getBoundingClientRect();\n\n  // Append as many cells as needed to replicate ship size\n  for (let i = 0; i < size; i++) {\n    const clone = cell.cloneNode(true);\n    clone.style.width = `${cellSize.width}px`;\n    clone.style.height = `${cellSize.height}px`;\n    clone.style.opacity = \"0.8\";\n    ghost.appendChild(clone);\n  }\n  document.body.appendChild(ghost);\n  return ghost;\n}\n\n// Allows ships to be dropped on a cell and registered\nfunction dropShip(cell) {\n  // Get the desired direction and the other direction\n  const direction = dragData.direction;\n  const other = direction === 'vertical' ? 'horizontal' : 'vertical';\n  // Get the static coordinate from the other direction coordiante of the cell\n  const staticCoord = cell.dataset[other];\n  // Get the direction coordinate and the required empty cells next to this one\n  const directionCoord = parseInt(cell.dataset[direction]);\n  const required = dragData.size - 1;\n  // If the ship would go over the edge, return\n  if ((directionCoord + required) > 9) {\n    return;\n  } \n  // For all cells we are about to occupy, if a ship is on any, return\n  for (let i = directionCoord; i < (directionCoord + dragData.size); i++) {\n    const targetCell = document.querySelector(`.cell-inner[data-${direction}='${i}'][data-${other}='${staticCoord}']`);\n    if (targetCell.classList.contains('cell-ship')) {\n      return;\n    }\n  }\n  // If there is no ship and no overflow, place the ship on all the cells\n  for (let i = directionCoord; i < (directionCoord + dragData.size); i++) {\n    const targetCell = document.querySelector(`.cell-inner[data-${direction}='${i}'][data-${other}='${staticCoord}']`);\n    targetCell.classList.add('cell-ship');\n  }\n  // Remove the placed ship from the ship selector\n  const selectedShip = document.querySelectorAll(`.ship[data-ship='${dragData.ship}']`);\n  selectedShip.forEach(part => {\n    part.classList.remove('ship');\n  });\n  // Save the data in the placement object\n  setupData.shipPlacement[dragData.ship] = {\n    coord: [parseInt(cell.dataset.vertical), parseInt(cell.dataset.horizontal)],\n    size: dragData.size,\n    direction: dragData.direction,\n  };\n  // Check if the user is done and if so activate confirm button\n  validateUserSetup();\n}\n\n// Places the random ships handed by the gameflow\nfunction randomizeShips(placements) {\n  // Replace the current placements with the random ones\n  for (const ship in placements) {\n    setupData.shipPlacement[ship] = placements[ship];\n  }\n  // Reset the placement board before setting new cells\n  const placedShips = document.querySelectorAll('.cell-ship');\n  placedShips.forEach(ship => {\n    ship.classList.remove('cell-ship');\n  });\n  // Set all cells in the ship coordinates to a ship cell\n  for (const shipObject in setupData.shipPlacement) {\n    const ship = setupData.shipPlacement[shipObject];\n    const staticCoord = ship.direction === 'horizontal' ? ship.coord[0] : ship.coord[1];\n    const movingCoord = ship.direction === 'horizontal' ? ship.coord[1] : ship.coord[0];\n    const otherDirection = ship.direction === 'horizontal' ? 'vertical' : 'horizontal';\n    for (let i = 0; i < ship.size; i++) {\n      const position = movingCoord + i;\n      const cell = document.querySelector(`[data-${otherDirection}='${staticCoord}'][data-${ship.direction}='${position}']`);\n      cell.classList.add('cell-ship');\n    }\n  }\n  // disappear all ships on the selection\n  const shipSelection = document.querySelectorAll('[data-current]');\n  shipSelection.forEach(cell => {\n    cell.classList.remove('ship');\n  });\n  // check validation\n  validateUserSetup();\n}\n\n/* ----- TURNS ----- */\n// Set up the turn\nfunction turn(state, status) {\n  const name = state.players[state.turn].name;\n  if (status === 'first') {\n    resetMaps();\n    setup.style.display = 'none';\n    player1.style.display = 'none';\n    player2.style.display = 'none';\n    currentPlayer.textContent = name;\n    startButton.style.display = 'block';\n    announce.textContent = `${makePossessive(name)} turn.`;\n  } else if (status === 'start') {\n    // Get the other players location in the array\n    const otherPlayer = state.turn === 0 ? 1 : 0;\n    // Get the two gameboards and show them\n    const playerGameboard = state.players[state.turn].gameboard;\n    const enemyGameboard = state.players[otherPlayer].gameboard;\n    createGameboard('player', playerGameboard);\n    createGameboard('enemy', enemyGameboard);\n    // Show and hide elements\n    startButton.style.display = 'none';\n    player1.style.display = 'block';\n    player2.style.display = 'block';\n    fireButton.style.display = 'block';\n    announce.textContent = 'Select a coordinate for your attack.';\n    state.turnEnd = false;\n  } else {\n    // Hide maps and reset them\n    player1.style.display = 'none';\n    player2.style.display = 'none';\n    resetMaps();\n    // Hide other elements\n    fireButton.style.display = 'none';\n    endButton.style.display = 'none';\n    // Get the current players name, and change textContents\n    const name = state.players[state.turn].name;\n    currentPlayer.textContent = name;\n    announce.textContent = `${makePossessive(name)} turn.`;\n    startButton.style.display = 'block';\n  }\n}\n\n// Register an attack result \nfunction registerAttack(state, result, coords, cpu) {\n  fireButton.disabled = true;\n  state.attackTarget = [];\n  // Get the other players location in the array and their gameboard\n  const otherPlayer = state.turn === 0 ? 1 : 0;\n  const gameboard = state.players[otherPlayer].gameboard;\n  // Get the name of the current player and the attack details\n  const name = state.players[state.turn].name;\n  const readableCoords = makeReadableCoords(coords);\n  const logResult = result.hit ? 'Hit.' : 'Miss.'\n  // Remove the current gameboard and show the updated one with the attack\n  if (cpu) {\n    player1.querySelector('.gameboard').remove();\n    createGameboard('player', gameboard);\n    endButton.style.display = 'none';\n  } else {\n    player2.querySelector('.gameboard').remove();\n    createGameboard('enemy', gameboard);\n    fireButton.style.display = 'none';\n  }\n  // Check if the game is over and show appropriate messages\n  if (result.allSunk) {\n    const attackResult = `${name} attacks ${readableCoords}. ${logResult}`;\n    const gameResult = `All ships destroyed. ${name} wins.`;\n    announce.textContent = `${attackResult} ${gameResult}`;\n  } else {\n    announce.textContent = `${name} attacks ${readableCoords}. ${logResult}`;\n    if (cpu) {\n      fireButton.style.display = 'block';\n    } else {\n      endButton.style.display = 'block';\n    }\n    state.turnEnd = cpu ? false : true;\n  }\n}\n\n// Create the gameboard visual from the gameboard data\nfunction createGameboard(boardType, gameboard) {\n  // If the board type is player, all ships can be shown, if enemy, only hits\n  const playerField = boardType === 'player' ? player1 : player2;\n  const gameboardDiv = document.createElement('div');\n  const coordMap = {\n    1: 'A',\n    2: 'B',\n    3: 'C',\n    4: 'D',\n    5: 'E',\n    6: 'F',\n    7: 'G',\n    8: 'H',\n    9: 'I',\n    10: 'J',\n  }\n  gameboardDiv.classList.add('gameboard');\n  for (let i = 0; i < 11; i++) {\n    for (let j = 0; j < 11; j++) {\n      const cell = document.createElement('div');\n      // Add player or enemy class to the cell, as well as location in grid\n      cell.classList.add(boardType);\n      cell.dataset.horizontal = j;\n      cell.dataset.vertical = i;\n      if (i === 0) {\n        cell.classList.add('cell-outer');\n        if (j !== 0) {\n          cell.textContent = j;\n        }\n      } else if (j === 0) {\n        cell.classList.add('cell-outer');\n        cell.textContent = coordMap[i];\n      } else {\n        cell.classList.add('cell-inner');\n        const gameboardCell = gameboard.grid[i-1][j-1];\n        // If the board is the player's show all ships and attacks by the enemy\n        if (boardType === 'player') {\n          if (gameboardCell.ship) {\n            cell.classList.add('cell-ship');\n          }\n          if (gameboardCell.attacked) {\n            cell.classList.add('cell-attacked');\n          }\n        } else {\n          // On the enemy board, only show attacked cells (and ships in them)\n          if (gameboardCell.attacked) {\n            cell.classList.add('cell-attacked');\n            if (gameboardCell.ship) {\n              cell.classList.add('cell-ship');\n            }\n          }\n          // Add the listener for a cell to be clicked to attack\n          cell.addEventListener('click', () => {\n            clickCell(cell);\n          })\n        }\n      }\n      gameboardDiv.appendChild(cell);\n    }\n  }\n  playerField.appendChild(gameboardDiv);\n}\n\n// Click a cell to select it for attack\nfunction clickCell(cell) {\n  // Deselect the current cell and their coordinate pairs\n  const currentClicked = document.querySelector('.cell-clicked');\n  if (currentClicked) {\n    const [currentOuterHorizontal, currentOuterVertical] = getOuter(currentClicked);\n    currentClicked.classList.remove('cell-clicked');\n    currentOuterHorizontal.dataset.selected = 'false';\n    currentOuterVertical.dataset.selected = 'false';\n  }\n  // Do not allow already attacked cells to be selected\n  if (cell.classList.contains('cell-attacked') || state.turnEnd) {\n    fireButton.disabled = true;\n    return;\n  }\n  // Get the outer cells to highlight them \n  const [outerHorizontal, outerVertical] = getOuter(cell);\n  cell.classList.add('cell-clicked');\n  outerHorizontal.dataset.selected = 'true';\n  outerVertical.dataset.selected = 'true';\n  // Send the current coordinate to the attackTarget variable\n  state.attackTarget = [parseInt(cell.dataset.vertical) - 1, parseInt(cell.dataset.horizontal) - 1];\n  fireButton.disabled = false;\n}\n\n// Get the outter cells that contain the coordinate symbols for highlighting\nfunction getOuter(cell) {\n  const horizontal = cell.dataset.horizontal;\n  const vertical = cell.dataset.vertical;\n  const horizontalOuter = document.querySelector(`.enemy[data-horizontal='${horizontal}'][data-vertical='0']`);\n  const verticalOuter = document.querySelector(`.enemy[data-horizontal='0'][data-vertical='${vertical}']`);\n  return [horizontalOuter, verticalOuter]\n}\n\n// Make the correct possessive form for the players name\nfunction makePossessive(name) {\n  name = name.trim();\n  // Check if name ends with 's' or 'S'\n  if (/[sS]$/.test(name)) {\n    return `${name}'`;\n  } else {\n    return `${name}'s`;\n  }\n}\n\n// Create a readable coordinate pair\nfunction makeReadableCoords(coords) {\n  // Exchange row integer with letter, add 1 to col\n  const [row, col] = coords;\n  const rowMap = {\n    0: 'A',\n    1: 'B',\n    2: 'C',\n    3: 'D',\n    4: 'E',\n    5: 'F',\n    6: 'G',\n    7: 'H',\n    8: 'I',\n    9: 'J',\n  };\n  return `${rowMap[row]}${col + 1}`;\n}\n\n\n\n//# sourceURL=webpack://odin-battleship/./src/interface.js?\n}");

/***/ }),

/***/ "./src/players.js":
/*!************************!*\
  !*** ./src/players.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Player: () => (/* binding */ Player)\n/* harmony export */ });\n/* harmony import */ var _gameboard_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gameboard.js */ \"./src/gameboard.js\");\n\n\nclass Player {\n  constructor(name, ships) {\n    this.gameboard = (0,_gameboard_js__WEBPACK_IMPORTED_MODULE_0__.createGameboard)(ships);\n    this.name = name;\n  }\n}\n\n\n\n//# sourceURL=webpack://odin-battleship/./src/players.js?\n}");

/***/ }),

/***/ "./src/ships.js":
/*!**********************!*\
  !*** ./src/ships.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ship: () => (/* binding */ Ship)\n/* harmony export */ });\n// The ship class that handles ships on the map\nclass Ship {\n  // The ship only saves it's own health\n  constructor(length) {\n    this.health = length;\n  }\n\n  // On hit, lose one point\n  hit() {\n    this.health--;\n  }\n\n  // Check if ship is sunk, if health is 0, it is sunk\n  isSunk() {\n    return this.health === 0;\n  }\n}\n\n\n\n//# sourceURL=webpack://odin-battleship/./src/ships.js?\n}");

/***/ }),

/***/ "./src/styles.css":
/*!************************!*\
  !*** ./src/styles.css ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./src/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://odin-battleship/./src/styles.css?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = (typeof document !== 'undefined' && document.baseURI) || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/gameflow.js");
/******/ 	
/******/ })()
;